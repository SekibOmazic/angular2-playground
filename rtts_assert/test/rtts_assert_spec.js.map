{"version":3,"sources":["@traceur/generated/TemplateParser/22","rtts_assert/test/rtts_assert_spec.es6","@traceur/generated/TemplateParser/8","@traceur/generated/TemplateParser/33","rtts_assert/test/@traceur/generated/TemplateParser/8","rtts_assert/test/@traceur/generated/TemplateParser/7","rtts_assert/test/@traceur/generated/TemplateParser/10","rtts_assert/test/@traceur/generated/TemplateParser/9","rtts_assert/test/@traceur/generated/TemplateParser/389","rtts_assert/test/@traceur/generated/TemplateParser/25","@traceur/generated/TemplateParser/30","@traceur/generated/TemplateParser/21","@traceur/generated/TemplateParser/20","@traceur/generated/TemplateParser/26","rtts_assert/test/rtts_assert_spec.js"],"names":[],"mappings":"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","file":"rtts_assert/test/rtts_assert_spec.js","sourceRoot":"/Users/jbisa/ksi/devel/angular2/dist/js/dev/es6/","sourcesContent":["System.register($__placeholder__0, function($__export) {\n          $__placeholder__1\n        });","// # Assert.js\n// A run-time type assertion library for JavaScript. Designed to be used with [Traceur](https://github.com/google/traceur-compiler).\n\n\n// - [Basic Type Check](#basic-type-check)\n// - [Custom Check](#custom-check)\n// - [Primitive Values](#primitive-values)\n// - [Describing more complex types](#describing-more-complex-types)\n//   - [assert.arrayOf](#assert-arrayof)\n//   - [assert.structure](#assert-structure)\n// - [Integrating with Traceur](#integrating-with-traceur)\n\n// Note: `assert` gets automatically included by traceur!\n\nexport function main() {\n\ndescribe('prettyPrint', () => {\n  class Type {};\n\n  it('should limit the number of printed properties', () => {\n    var o = {};\n    for (var i = 0; i < 100; i++) {\n      o['p_' + i] = i;\n    }\n    try {\n      assert.type(o, Type);\n      throw 'fail!';\n    } catch (e) {\n      expect(e.message.indexOf('p_0')).toBeGreaterThan(-1);\n      expect(e.message.indexOf('...')).toBeGreaterThan(-1);\n      expect(e.message.indexOf('p_20')).toBe(-1);\n    }\n  });\n\n  it('should limit the depth of printed properties', () => {\n    var o = {l1: {l2: {l3: {l4: {l5: {l6: 'deep'}}}}}};\n\n    expect(() => {\n      assert.type(o, Type);\n    }).toThrowError('Expected an instance of Type, got {l1: {l2: {l3: {l4: [...]}}}}!');\n  });\n});\n\n// ## Basic Type Check\n// By default, `instanceof` is used to check the type.\n//\n// Note that you can use `assert.type()` in unit tests or anywhere in your code.\n// Most of the time, you will use it with Traceur.\n// Jump to the [Traceur section](#integrating-with-traceur) to see an example of that.\ndescribe('basic type check', function() {\n\n  class Type {}\n\n  it('should pass', function() {\n    assert.type(new Type(), Type);\n  });\n\n\n  it('should fail', function() {\n    expect(() => assert.type(123, Type))\n      .toThrowError('Expected an instance of Type, got 123!');\n  });\n\n\n  it('should allow null', function() {\n    assert.type(null, Type);\n  });\n});\n\n\n\n// ## Custom Check\n// Often, `instanceof` is not flexible enough.\n// In that case, your type can define its own `assert` method which will be used instead.\n//\n// See [Describing More Complex Types](#describing-more-complex-types) for examples how to\n// define custom checks using `assert.define()`.\ndescribe('custom check', function() {\n\n  class Type {}\n\n  // the basic check can just return true/false, without specifying any reason\n  it('should pass when returns true', function() {\n    Type.assert = function(value) {\n      return true;\n    };\n\n    assert.type({}, Type);\n  });\n\n\n  it('should fail when returns false', function() {\n    Type.assert = function(value) {\n      return false;\n    };\n\n    expect(() => assert.type({}, Type))\n      .toThrowError('Expected an instance of Type, got {}!');\n  });\n\n\n  // Using `assert.fail()` allows to report even multiple errors.\n  it('should fail when calls assert.fail()', function() {\n    Type.assert = function(value) {\n      assert.fail('not smart enough');\n      assert.fail('not blue enough');\n    };\n\n    expect(() => assert.type({}, Type))\n      .toThrowError('Expected an instance of Type, got {}!\\n' +\n                    '  - not smart enough\\n' +\n                    '  - not blue enough');\n  });\n\n\n  it('should fail when throws an exception', function() {\n    Type.assert = function(value) {\n      throw new Error('not long enough');\n    };\n\n    expect(function() {\n      assert.type(12345, Type);\n    }).toThrowError('Expected an instance of Type, got 12345!\\n' +\n                    '  - not long enough');\n  });\n});\n\n\n\n// ## Primitive Values\n// You don't want to check primitive values (such as strings, numbers, or booleans) using `typeof` rather than\n// `instanceof`.\n//\n// Again, you probably won't write this code and rather use Traceur to do it for you, simply based on type annotations.\ndescribe('primitive value check', function() {\n  var primitive = $traceurRuntime.type;\n\n  describe('string', function() {\n\n    it('should pass', function() {\n      assert.type('xxx', primitive.string);\n    });\n\n\n    it('should fail', function() {\n      expect(() => assert.type(12345, primitive.string))\n        .toThrowError('Expected an instance of string, got 12345!');\n    });\n\n    it('should allow null', function() {\n      assert.type(null, primitive.string);\n    });\n  });\n\n\n  describe('number', function() {\n\n    it('should pass', function() {\n      assert.type(123, primitive.number);\n    });\n\n\n    it('should fail', function() {\n      expect(() => assert.type(false, primitive.number))\n        .toThrowError('Expected an instance of number, got false!');\n    });\n\n    it('should allow null', function() {\n      assert.type(null, primitive.number);\n    });\n  });\n\n\n  describe('boolean', function() {\n\n    it('should pass', function() {\n      expect(assert.type(true, primitive.boolean)).toBe(true);\n      expect(assert.type(false, primitive.boolean)).toBe(false);\n    });\n\n\n    it('should fail', function() {\n      expect(() => assert.type(123, primitive.boolean))\n        .toThrowError('Expected an instance of boolean, got 123!');\n    });\n\n    it('should allow null', function() {\n      assert.type(null, primitive.boolean);\n    });\n  });\n});\n\n\n// ## Describing more complex types\n//\n// Often, a simple type check using `instanceof` or `typeof` is not enough.\n// That's why you can define custom checks using this DSL.\n// The goal was to make them easy to compose and as descriptive as possible.\n// Of course you can write your own DSL on the top of this.\ndescribe('define', function() {\n\n  // If the first argument to `assert.define()` is a type (function), it will define `assert` method on that function.\n  //\n  // In this example, being a type of Type means being a either a function or object.\n  it('should define assert for an existing type', function() {\n    class Type {}\n\n    assert.define(Type, function(value) {\n      assert(value).is(Function, Object);\n    });\n\n    assert.type({}, Type);\n    assert.type(function() {}, Type);\n    expect(() => assert.type('str', Type))\n      .toThrowError('Expected an instance of Type, got \"str\"!\\n' +\n                    '  - \"str\" is not instance of Function\\n' +\n                    '  - \"str\" is not instance of Object');\n  });\n\n\n  // If the first argument to `assert.define()` is a string,\n  // it will create an interface - basically an empty class with `assert` method.\n  it('should define an interface', function() {\n    var User = assert.define('MyUser', function(user) {\n      assert(user).is(Object);\n    });\n\n    assert.type({}, User);\n    expect(() => assert.type(12345, User))\n      .toThrowError('Expected an instance of MyUser, got 12345!\\n' +\n                    '  - 12345 is not instance of Object');\n  });\n\n\n  // Here are a couple of more APIs to describe your custom types...\n  //\n  // ### assert.arrayOf\n  // Checks if the value is an array and if so, it checks whether all the items are one the given types.\n  // These types can be composed types, not just simple ones.\n  describe('arrayOf', function() {\n\n    var Titles = assert.define('ListOfTitles', function(value) {\n      assert(value).is(assert.arrayOf(assert.string, assert.number));\n    });\n\n    it('should pass', function () {\n      assert.type(['one', 55, 'two'], Titles);\n    });\n\n\n    it('should fail when non-array given', function () {\n      expect(() => assert.type('foo', Titles))\n        .toThrowError('Expected an instance of ListOfTitles, got \"foo\"!\\n' +\n                      '  - \"foo\" is not instance of array of string/number\\n' +\n                      '    - \"foo\" is not instance of Array');\n    });\n\n\n    it('should fail when an invalid item in the array', function () {\n      expect(() => assert.type(['aaa', true], Titles))\n        .toThrowError('Expected an instance of ListOfTitles, got [\"aaa\", true]!\\n' +\n                      '  - [\"aaa\", true] is not instance of array of string/number\\n' +\n                      '    - true is not instance of string\\n' +\n                      '    - true is not instance of number');\n    });\n  });\n\n\n  // ### assert.structure\n  // Similar to `assert.arrayOf` which checks a content of an array,\n  // `assert.structure` checks if the value is an object with specific properties.\n  describe('structure', function() {\n\n    var User = assert.define('MyUser', function(value) {\n      assert(value).is(assert.structure({\n        name: assert.string,\n        age: assert.number\n      }));\n    });\n\n    it('should pass', function () {\n      assert.type({name: 'Vojta', age: 28}, User);\n    });\n\n\n    it('should fail when non-object given', function () {\n      expect(() => assert.type(123, User))\n        .toThrowError('Expected an instance of MyUser, got 123!\\n' +\n                      '  - 123 is not instance of object with properties name, age\\n' +\n                      '    - 123 is not instance of Object');\n    });\n\n\n    it('should fail when an invalid property', function () {\n      expect(() => assert.type({name: 'Vojta', age: true}, User))\n        .toThrowError('Expected an instance of MyUser, got {name: \"Vojta\", age: true}!\\n' +\n                      '  - {name: \"Vojta\", age: true} is not instance of object with properties name, age\\n' +\n                      '    - true is not instance of number');\n    });\n  });\n});\n\n\n\n// ## Integrating with Traceur\n//\n// Manually calling `assert.type()` in your code is cumbersome. Most of the time, you'll want to\n// have Traceur add the calls to `assert.type()` to your code based on type annotations.\n//\n// This has several advantages:\n// - it's shorter and nicer,\n// - you can easily ignore it when generating production code.\n//\n// You'll need to run Traceur with `--types=true --type-assertions=true --type-assertion-module=\"path/to/assert\"`.\ndescribe('Traceur', function() {\n\n  describe('arguments', function() {\n\n    function reverse(str: string) {\n      return str ? reverse(str.substring(1)) + str[0] : ''\n    }\n\n    it('should pass', function() {\n      expect(reverse('angular')).toBe('ralugna');\n    });\n\n\n    it('should fail', function() {\n      expect(() => reverse(123))\n        .toThrowError('Invalid arguments given!\\n' +\n                      '  - 1st argument has to be an instance of string, got 123');\n    });\n  });\n\n\n  describe('return value', function() {\n\n    function foo(bar): number {\n      return bar;\n    }\n\n    it('should pass', function() {\n      expect(foo(123)).toBe(123);\n    });\n\n\n    it('should fail', function() {\n      expect(() => foo('bar'))\n        .toThrowError('Expected to return an instance of number, got \"bar\"!');\n    });\n  });\n\n\n  describe('variables', function() {\n\n    it('should pass', function() {\n      var count:number = 1;\n    });\n\n\n    it('should fail', function() {\n      expect(() => {\n        var count: number = true;\n      }).toThrowError('Expected an instance of number, got true!');\n    });\n  });\n\n\n  describe('void', function() {\n    function foo(bar): void {\n      return bar;\n    }\n\n    it('should pass when not defined', function() {\n      function nonReturn(): void {}\n      function returnNothing(): void { return; }\n      function returnUndefined(): void { return undefined; }\n\n      foo();\n      foo(undefined);\n      nonReturn();\n      returnNothing();\n      returnUndefined();\n    });\n\n\n    it('should fail when a value returned', function() {\n      expect(() => foo('bar'))\n        .toThrowError('Expected to return an instance of void, got \"bar\"!');\n    });\n\n\n    it('should fail when null returned', function() {\n      expect(() => foo(null))\n        .toThrowError('Expected to return an instance of void, got null!');\n    });\n  });\n\n\n  describe('generics', function() {\n\n    it('should pass', function() {\n      var list:Array<string> = [];\n    });\n\n    // TODO(tbosch): add assertions based on generics to rtts_assert\n\n  });\n\n});\n\n}\n","var $__placeholder__0 = $__placeholder__1","($traceurRuntime.createClass)($__placeholder__0, $__placeholder__1, $__placeholder__2)","assert.argumentTypes($__placeholder__0)","assert.type.$__placeholder__0)","Object.defineProperty($__placeholder__0, $__placeholder__1,\n        {get: function() {return $__placeholder__2}});","return assert.returnType(($__placeholder__0), $__placeholder__1)","assert.type($__placeholder__0, $__placeholder__1)","assert.genericType($__placeholder__0)","\n        $__export($__placeholder__0, $__placeholder__1)\n      ","return {\n      setters: $__placeholder__0,\n      execute: $__placeholder__1\n    }","function($__m) {\n          $__placeholder__0\n        }","$__placeholder__0 = $__m.$__placeholder__1;","import {assert} from \"rtts_assert/rtts_assert\";\nexport function main() {\n  describe('prettyPrint', () => {\n    class Type {}\n    ;\n    it('should limit the number of printed properties', () => {\n      var o = {};\n      for (var i = 0; i < 100; i++) {\n        o['p_' + i] = i;\n      }\n      try {\n        assert.type(o, Type);\n        throw 'fail!';\n      } catch (e) {\n        expect(e.message.indexOf('p_0')).toBeGreaterThan(-1);\n        expect(e.message.indexOf('...')).toBeGreaterThan(-1);\n        expect(e.message.indexOf('p_20')).toBe(-1);\n      }\n    });\n    it('should limit the depth of printed properties', () => {\n      var o = {l1: {l2: {l3: {l4: {l5: {l6: 'deep'}}}}}};\n      expect(() => {\n        assert.type(o, Type);\n      }).toThrowError('Expected an instance of Type, got {l1: {l2: {l3: {l4: [...]}}}}!');\n    });\n  });\n  describe('basic type check', function() {\n    class Type {}\n    it('should pass', function() {\n      assert.type(new Type(), Type);\n    });\n    it('should fail', function() {\n      expect(() => assert.type(123, Type)).toThrowError('Expected an instance of Type, got 123!');\n    });\n    it('should allow null', function() {\n      assert.type(null, Type);\n    });\n  });\n  describe('custom check', function() {\n    class Type {}\n    it('should pass when returns true', function() {\n      Type.assert = function(value) {\n        return true;\n      };\n      assert.type({}, Type);\n    });\n    it('should fail when returns false', function() {\n      Type.assert = function(value) {\n        return false;\n      };\n      expect(() => assert.type({}, Type)).toThrowError('Expected an instance of Type, got {}!');\n    });\n    it('should fail when calls assert.fail()', function() {\n      Type.assert = function(value) {\n        assert.fail('not smart enough');\n        assert.fail('not blue enough');\n      };\n      expect(() => assert.type({}, Type)).toThrowError('Expected an instance of Type, got {}!\\n' + '  - not smart enough\\n' + '  - not blue enough');\n    });\n    it('should fail when throws an exception', function() {\n      Type.assert = function(value) {\n        throw new Error('not long enough');\n      };\n      expect(function() {\n        assert.type(12345, Type);\n      }).toThrowError('Expected an instance of Type, got 12345!\\n' + '  - not long enough');\n    });\n  });\n  describe('primitive value check', function() {\n    var primitive = $traceurRuntime.type;\n    describe('string', function() {\n      it('should pass', function() {\n        assert.type('xxx', primitive.string);\n      });\n      it('should fail', function() {\n        expect(() => assert.type(12345, primitive.string)).toThrowError('Expected an instance of string, got 12345!');\n      });\n      it('should allow null', function() {\n        assert.type(null, primitive.string);\n      });\n    });\n    describe('number', function() {\n      it('should pass', function() {\n        assert.type(123, primitive.number);\n      });\n      it('should fail', function() {\n        expect(() => assert.type(false, primitive.number)).toThrowError('Expected an instance of number, got false!');\n      });\n      it('should allow null', function() {\n        assert.type(null, primitive.number);\n      });\n    });\n    describe('boolean', function() {\n      it('should pass', function() {\n        expect(assert.type(true, primitive.boolean)).toBe(true);\n        expect(assert.type(false, primitive.boolean)).toBe(false);\n      });\n      it('should fail', function() {\n        expect(() => assert.type(123, primitive.boolean)).toThrowError('Expected an instance of boolean, got 123!');\n      });\n      it('should allow null', function() {\n        assert.type(null, primitive.boolean);\n      });\n    });\n  });\n  describe('define', function() {\n    it('should define assert for an existing type', function() {\n      class Type {}\n      assert.define(Type, function(value) {\n        assert(value).is(Function, Object);\n      });\n      assert.type({}, Type);\n      assert.type(function() {}, Type);\n      expect(() => assert.type('str', Type)).toThrowError('Expected an instance of Type, got \"str\"!\\n' + '  - \"str\" is not instance of Function\\n' + '  - \"str\" is not instance of Object');\n    });\n    it('should define an interface', function() {\n      var User = assert.define('MyUser', function(user) {\n        assert(user).is(Object);\n      });\n      assert.type({}, User);\n      expect(() => assert.type(12345, User)).toThrowError('Expected an instance of MyUser, got 12345!\\n' + '  - 12345 is not instance of Object');\n    });\n    describe('arrayOf', function() {\n      var Titles = assert.define('ListOfTitles', function(value) {\n        assert(value).is(assert.arrayOf(assert.string, assert.number));\n      });\n      it('should pass', function() {\n        assert.type(['one', 55, 'two'], Titles);\n      });\n      it('should fail when non-array given', function() {\n        expect(() => assert.type('foo', Titles)).toThrowError('Expected an instance of ListOfTitles, got \"foo\"!\\n' + '  - \"foo\" is not instance of array of string/number\\n' + '    - \"foo\" is not instance of Array');\n      });\n      it('should fail when an invalid item in the array', function() {\n        expect(() => assert.type(['aaa', true], Titles)).toThrowError('Expected an instance of ListOfTitles, got [\"aaa\", true]!\\n' + '  - [\"aaa\", true] is not instance of array of string/number\\n' + '    - true is not instance of string\\n' + '    - true is not instance of number');\n      });\n    });\n    describe('structure', function() {\n      var User = assert.define('MyUser', function(value) {\n        assert(value).is(assert.structure({\n          name: assert.string,\n          age: assert.number\n        }));\n      });\n      it('should pass', function() {\n        assert.type({\n          name: 'Vojta',\n          age: 28\n        }, User);\n      });\n      it('should fail when non-object given', function() {\n        expect(() => assert.type(123, User)).toThrowError('Expected an instance of MyUser, got 123!\\n' + '  - 123 is not instance of object with properties name, age\\n' + '    - 123 is not instance of Object');\n      });\n      it('should fail when an invalid property', function() {\n        expect(() => assert.type({\n          name: 'Vojta',\n          age: true\n        }, User)).toThrowError('Expected an instance of MyUser, got {name: \"Vojta\", age: true}!\\n' + '  - {name: \"Vojta\", age: true} is not instance of object with properties name, age\\n' + '    - true is not instance of number');\n      });\n    });\n  });\n  describe('Traceur', function() {\n    describe('arguments', function() {\n      function reverse(str) {\n        assert.argumentTypes(str, assert.type.string);\n        return str ? reverse(str.substring(1)) + str[0] : '';\n      }\n      Object.defineProperty(reverse, \"parameters\", {get: function() {\n          return [[assert.type.string]];\n        }});\n      it('should pass', function() {\n        expect(reverse('angular')).toBe('ralugna');\n      });\n      it('should fail', function() {\n        expect(() => reverse(123)).toThrowError('Invalid arguments given!\\n' + '  - 1st argument has to be an instance of string, got 123');\n      });\n    });\n    describe('return value', function() {\n      function foo(bar) {\n        return assert.returnType((bar), assert.type.number);\n      }\n      it('should pass', function() {\n        expect(foo(123)).toBe(123);\n      });\n      it('should fail', function() {\n        expect(() => foo('bar')).toThrowError('Expected to return an instance of number, got \"bar\"!');\n      });\n    });\n    describe('variables', function() {\n      it('should pass', function() {\n        var count = assert.type(1, assert.type.number);\n      });\n      it('should fail', function() {\n        expect(() => {\n          var count = assert.type(true, assert.type.number);\n        }).toThrowError('Expected an instance of number, got true!');\n      });\n    });\n    describe('void', function() {\n      function foo(bar) {\n        return assert.returnType((bar), assert.type.void);\n      }\n      it('should pass when not defined', function() {\n        function nonReturn() {}\n        function returnNothing() {\n          return ;\n        }\n        function returnUndefined() {\n          return assert.returnType((undefined), assert.type.void);\n        }\n        foo();\n        foo(undefined);\n        nonReturn();\n        returnNothing();\n        returnUndefined();\n      });\n      it('should fail when a value returned', function() {\n        expect(() => foo('bar')).toThrowError('Expected to return an instance of void, got \"bar\"!');\n      });\n      it('should fail when null returned', function() {\n        expect(() => foo(null)).toThrowError('Expected to return an instance of void, got null!');\n      });\n    });\n    describe('generics', function() {\n      it('should pass', function() {\n        var list = assert.type([], assert.genericType(Array, assert.type.string));\n      });\n    });\n  });\n}\n\n//# sourceMappingURL=/Users/jbisa/ksi/devel/angular2/modules/rtts_assert/test/rtts_assert_spec.map\n\n//# sourceMappingURL=./rtts_assert_spec.map"]}